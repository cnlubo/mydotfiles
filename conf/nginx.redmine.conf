##### 全局块 #####

user                      www www;       #使用的用户和组 

worker_processes          1;                 #工作衍生进程数(一般等于cpu的总核数或总核数的两倍，例如两个四核cpu，则总核数为8

        error_log                 logs/error.log warn;     #错误日志存放路径，日志记录级别可选项为 debug|info|notice|warn|error|crit 日志信息量由大到小

        pid                       run/nginx.pid;           #pid 文件存放路径
        worker_rlimit_nofile      65535;

##### 全局块#####

##### events 块 #####

        events {
        use epoll;                 #事件驱动模型
        worker_connections  65535; #每个工作进程允许的最大连接数
        }

##### enents 块 #####

##### http 块  #####

        http {

            include       mime.types;

            default_type  application/octet-stream;

            server_names_hash_bucket_size 128;          #服务器名称的hash表大小

                client_header_buffer_size 4k;       #Nginx接受用户请求中HTTPheader部分(包括HTTP行和HTTP头部)时分配的buffer大小,默认1k,由于一般系统分页都要大于1k，所以设置为分页大小，分页大小                                                     通过getconf PAGESIZE命令获得
                large_client_header_buffers 4 32k;  #如果HTTP请求行（如GET/index HTTP/1.1）的大小超过上面的单个buffer，则返回“Request URI large”(414)。请求中一般会有许多header，每一个header                                                       的大小也不能超过单个buffer的大小，否则会返回“Bad request”(400)。当然，请求行和请求头部的总和也不可以超过buffer个数*buffer的大小小，此时上                                                      一个参数失效，本参数生效
                sendfile           on;              #开启高效文件传输模式

                tcp_nopush         on;              #防止网络堵塞

                tcp_nodelay        on;              #防止网络堵塞

                keepalive_timeout  60 50;           #参数1:Nginx服务器与客户端连接保持活动的时间，参数2:可选，使用Keep-Alive消息头保持与客户端某些浏览器(如 Mozilla,Konqueror 等)的连接时间

                client_max_body_size    10m;

            client_body_buffer_size 128k;

            #fastcgi 相关设置

            fastcgi_connect_timeout 300;

            fastcgi_send_timeout 300;

            fastcgi_read_timeout 300;

            fastcgi_buffer_size 16k;

            fastcgi_buffers 16 16k;

            fastcgi_busy_buffers_size 16k;

            fastcgi_temp_file_write_size 16k;

            #开启gzip
            gzip on;
            gzip_min_length     1k;      #最小压缩文件长度
                gzip_buffers     4  16k;     #压缩缓冲区大小，参数1为申请缓存空间的个数，参数2为每个缓存空间的大小
                gzip_http_version 1.1;       #
                gzip_comp_level 2;           #压缩级别
                gzip_types       text/plain application/x-javascript text/css application/xml; #启用压缩源文件的类型
                gzip_vary            on;                                                       #启用压缩标识
#gzip_static          on;
                gzip_disable         "MSIE[1-6]\.";         #ie6 以下浏览器关闭gzip

                open_file_cache max=65535 inactive=20s;
            open_file_cache_min_uses 1;
            open_file_cache_valid 30s;

#设置日志格式 位置可以在http{...}之间 也可以在server{...}之间
            log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '		
                '$status $body_bytes_sent "$http_referer" '
                '"$http_user_agent" "$http_x_forwarded_for" "$upstream_cache_status"';
#用来指定日志文件的存放路径、格式和缓存大小	
#		access_log  logs/host.access.log main;


            proxy_connect_timeout      90;     #nginx与后端被代理服务器连接超时时间
                proxy_send_timeout         90;     #nginx向后端被代理服务器发出write请求后，等待响应的超时时间
                proxy_read_timeout         90;     #nginx向后端被代理服务器发出read请求后，等待响应的超时时间 
                proxy_buffer_size          32k;     #默认设置为4或8k,保持与proxy_buffers 中的size大小相同，当然也可以设置的更小
                proxy_buffers              4  32k; #proxy_buffer 个数和每个buffer的大小
                proxy_busy_buffers_size    64k;  #限制同时处于BUSY状态的proxy_buffer的总大小
                proxy_temp_file_write_size 64k; #同时写入临时文件的数据量的总大小
                #proxy_cache_path          /usr/local/nginx/data/proxy_cache_dir levels=1:2 keys_zone=cache_one:150m inactive=1d max_size=10g;

##### server 

            passenger_root /usr/local/lib/ruby/gems/2.1.0/gems/passenger-5.0.16;
            passenger_friendly_error_pages off;
            passenger_ruby /usr/local/bin/ruby;
            passenger_user www;
            passenger_group www;

##配置虚拟主机 localhost
            server {
                listen       80;
                server_name  127.0.0.1;

                access_log  logs/resource.access.log  main;
#		error_page  404    /404.html; #错误页面
                location / {
# root   html;
# index  index.html index.htm;
                    proxy_pass http://127.0.0.1:8080/;
                    proxy_redirect off;
                    proxy_set_header HOST $host;
                    proxy_set_header X-Real-IP $remote_addr;
                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_buffering   on ; #是否启用或关闭Proxy Buffer 默认开启
                        #location          /wechatapi
                        # {proxy_pass http://127.0.0.1:8080/wechatapi;
                            #     access_log  logs/manager.access.log  main;		
                            #     proxy_redirect off;
                            #     proxy_set_header HOST $host;
                            #     proxy_set_header X-Real-IP $remote_addr;
                            #     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                            #     proxy_buffering   on ;  #是否启用或关闭Proxy Buffer 默认开启
                            # }
                        location ~ ^/redmine(/.*|$) {
                            alias /u01/wwwroot/redmine/public$1;
                            passenger_base_uri /redmine;
                            passenger_app_root /u01/wwwroot/redmine;
                            passenger_document_root /u01/wwwroot/redmine/public;
                            passenger_enabled on;
                            client_max_body_size 10m;
                        }
                }


# redirect server error pages to the static page /50x.html
#
                error_page   500 502 503 504  /50x.html;
                location = /50x.html {
                    root   html;
                }

# proxy the PHP scripts to Apache listening on 127.0.0.1:80
#
#location ~ \.php$ {
#    proxy_pass   http://127.0.0.1;
#}

# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
#
#location ~ \.php$ {
#    root           html;
#    fastcgi_pass   127.0.0.1:9000;
#    fastcgi_index  index.php;
#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
#    include        fastcgi_params;
#}

# deny access to .htaccess files, if Apache's document root
# concurs with nginx's one
#
#location ~ /\.ht {
#    deny  all;
#}
            }


# another virtual host using mix of IP-, name-, and port-based configuration
#
#server {
#    listen       8000;
#    listen       somename:8080;
#    server_name  somename  alias  another.alias;

#    location / {
#        root   html;
#        index  index.html index.htm;
#    }
#}


# HTTPS server
#
#server {
#    listen       443;
#    server_name  localhost;

#    ssl                  on;
#    ssl_certificate      cert.pem;
#    ssl_certificate_key  cert.key;

#    ssl_session_timeout  5m;

#    ssl_protocols  SSLv2 SSLv3 TLSv1;
#    ssl_ciphers  HIGH:!aNULL:!MD5;
#    ssl_prefer_server_ciphers   on;

#    location / {
#        root   html;
#        index  index.html index.htm;
#    }
#}
        }
